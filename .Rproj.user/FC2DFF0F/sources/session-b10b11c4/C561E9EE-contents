functions {

  matrix GP(int K, real C, real D, real S) { // Gaussian process function
    matrix[K, K] Rho;
    real KR;
    KR = K;

    for (i in 1:(K-1)) {
    for (j in (i+1):K) {
    Rho[i, j] = C * exp(-D * ((j-i)^2 / KR^2));
    Rho[j, i] = Rho[i, j];
    }
    }

    for (i in 1:K) {
    Rho[i, i] = 1;
    }

    return S * cholesky_decompose(Rho);
  }
}

data {

  int N; // sample size of women
  int A; // maximum age of women
  
  matrix[N,A] wealth; // age-specific absolute wealth
  matrix[N,A] diffwealth; // age-specific absolute wealth change
  matrix[N,A] mvwealth; // age-specific moving variance
  
  int N_miss_wealth; // number of missing data of absolute wealth
  int N_miss_diffwealth; // number of missing data of absolute wealth change
  int N_miss_mvwealth; // number of missing data of moving variance
  
  array[N,A] int wealth_miss; // indicator matrix for missing values (1 if missing and 0 if not) of absolute wealth
  array[N,A] int diffwealth_miss; // indicator matrix for missing values (1 if missing and 0 if not) of absolute wealth change
  array[N,A] int mvwealth_miss; // indicator matrix for missing values (1 if missing and 0 if not) of moving variance
  
  array[N,A] int baby; // probability of FR

}

parameters {

// global intercept
  real alpha;
// Gaussian process of age
  vector [A] mu_raw;
  real <lower = 0, upper = 1> mu_kappa;
  real <lower = 0> mu_tau;
  real <lower = 0> mu_delta;
// wealth
  vector [A] beta_wealth; // absolute wealth
  vector [A] gamma_wealth; // wealth change
  vector [A] delta_wealth; // cumulative moving variance
// missing wealth data
//absolute wealth
  matrix[N,A] wealth_impute;
  real nu;
  real<lower=0> sigma_wealth_miss;
//wealth change
  matrix[N,A] diffwealth_impute;
  real xi;
  real<lower=0> sigma_diffwealth_miss;
//moving variance
  matrix[N,A] mvwealth_impute;
  real omicron;
  real<lower=0> sigma_mvwealth_miss;
}

transformed parameters {

//Time-varying Gaussian process of age
  vector [A] mu;
  
    mu = GP(A, mu_kappa, mu_tau, mu_delta) * mu_raw;
    
//Bayesian data imputation

//absolute wealth
  matrix[N,A] wealth_full; //full wealth data (original + imputed)
  
  wealth_full = wealth; // making the merged data as the same as the original data
  
  if(N_miss_wealth > 0){       //telling where is the missing data that needs to be imputed  
    for(n in 1:N){
      for(a in 1:A){
        if(wealth_miss[n,a] == 1){
          wealth_full[n,a] = wealth_impute[n,a];  
        }else{
          wealth_full[n,a] = wealth[n,a];
        }
      }
      }
    }

//wealth change
  matrix[N,A] diffwealth_full; //full wealth data (original + imputed)
  
  diffwealth_full = diffwealth; // making the merged data as the same as the original data
  
  if(N_miss_diffwealth > 0){       //telling where is the missing data that needs to be imputed  
    for(n in 1:N){
      for(a in 1:A){
        if(diffwealth_miss[n,a] == 1){
          diffwealth_full[n,a] = diffwealth_impute[n,a];  
        }else{
          diffwealth_full[n,a] = diffwealth[n,a];
        }
      }
      }
    }

//wealth change
  matrix[N,A] mvwealth_full; //full wealth data (original + imputed)
  
  mvwealth_full = mvwealth; // making the merged data as the same as the original data
  
  if(N_miss_mvwealth > 0){       //telling where is the missing data that needs to be imputed  
    for(n in 1:N){
      for(a in 1:A){
        if(mvwealth_miss[n,a] == 1){
          mvwealth_full[n,a] = mvwealth_impute[n,a];  
        }else{
          mvwealth_full[n,a] = mvwealth[n,a];
        }
      }
      }
    }

}

model {
// global intercept
    alpha ~ normal(0,1);
// Gaussian process of age    
    mu_raw ~ normal(0, 1);
    mu_kappa ~ beta(12, 2);
    mu_tau ~ exponential(1);
    mu_delta ~ exponential(1);
// cumulative moving variance
    delta_wealth ~ normal(0,1);
// missing wealth data
  for (n in 1:N) {
  for (a in 1:A) {
    if(wealth_miss[n,a]==1){
      wealth_impute[n,a] ~ normal(nu,sigma_wealth_miss);  
    }
    if(diffwealth_miss[n,a]==1){
      diffwealth_impute[n,a] ~ normal(xi,sigma_diffwealth_miss);  
    }
    if(mvwealth_miss[n,a]==1){
      mvwealth_impute[n,a] ~ normal(omicron,sigma_mvwealth_miss);  
    }
  }
  }
    nu ~ normal(0,1);
    sigma_wealth_miss ~ exponential(1);
    chi ~ normal(0,1);
    sigma_diffwealth_miss ~ exponential(1);
    omicron ~ normal(0,1);
    sigma_mvwealth_miss ~ exponential(1);
    
    
  for (n in 1:N) {
  for (a in 1:A) {
    
    if(baby[n,a] != -99){

      baby[n, a] ~ bernoulli_logit( // Prob of having your first child
        alpha + // global intercept
        mu[a] + // age
        beta_wealth[a]*wealth_full[n,a] + // absolute wealth
        gamma_wealth[a]*diffwealth_full[n,a] + // wealth change
        delta_wealth[a]*mvwealth_full[n,a] + // moving variance
        );
          
    }
    }
    }

}
